# Lockers Control & Desktop Launcher

## Quick Start & Downloads

Grab the freshest builds from the **vNEXT** GitHub Release:

- **Windows**: [Lockers Control Installer (.msi)](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/Lockers-Setup-x64.msi) • [Portable one-folder (.exe)](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/Lockers-Setup-x64.exe)
- **macOS**: [Lockers Control Universal Disk Image (.dmg)](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/LockersCL.dmg)
- **Ubuntu**: [Debian package (.deb)](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/lockerscl_amd64.deb) • [Generic archive (.tar.gz)](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/LockersCL-linux-x64.tar.gz)
- **Android**: [Kiosk WebView APK](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/lockerscl-android-arm64.apk)

Download the matching [SHA256SUMS](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/SHA256SUMS) (and optional [SHA256SUMS.sig](https://github.com/lockers-cl/lockers-cl/releases/download/vNEXT/SHA256SUMS.sig)) file, then verify the artefacts before installation:

```bash
sha256sum -c SHA256SUMS
```

Unsigned community builds are clearly labelled in the release notes. On macOS and Windows you may need to approve the app via Gatekeeper/SmartScreen when signatures are unavailable.

## How It Works

Lockers Control couples a Django web tier that issues and redeems QR-based access codes with a serial driver that speaks to the locker controller. Operators issue QR codes, users present them at the kiosk, and the backend validates the request, dispatches the unlock command over serial, and then cleans up the QR artefact. The kiosk launcher (desktop or Android WebView) boots the backend locally when possible and falls back to a configured LAN server when not.

## Build It Yourself

The full contributor guide lives in [docs/BUILD_AND_CONTRIBUTE.md](docs/BUILD_AND_CONTRIBUTE.md). Quick recipes:

- **Windows**

  ```powershell
  py -3.11 -m venv .venv; .venv\Scripts\activate; pip install -r requirements.txt; pyinstaller lockers.spec
  ```

- **macOS**

  ```bash
  python3.11 -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt && pyinstaller lockers.spec
  ```

- **Ubuntu / Linux**

  ```bash
  sudo apt install -y build-essential libgtk-3-dev libcairo2-dev gir1.2-webkit2-4.0
  python3 -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt && pyinstaller lockers.spec
  ```

- **Android**

  ```bash
  cd android && ./gradlew assembleRelease
  ```

Continue below for a deeper architecture tour, installation notes, and contributor workflow.

## Project Overview

The system revolves around an embedded controller connected to locker hardware. Operators interact with lockers through QR codes that are generated by the web application. When a QR code is scanned, the web tier talks to the controller via serial commands to unlock the requested locker and records the transaction for auditing.

Key components:

- **`lockers.py`** – Coordinates the desktop GUI launcher, ensures Python dependencies are present, and starts the Django server in a subprocess when running in kiosk mode.
- **`web/` app** – Holds the Django models, views, forms, and URLs that power the QR code flow and the administrative pages.
- **`web/locker.py`** – Encapsulates serial communication helpers, QR-code cleanup, and command orchestration for the locker hardware.
- **`tests/`** – Regression tests that cover the desktop launcher behaviour and the locker utilities without requiring real hardware.

## How the Locker Workflow Operates

1. **Locker Definition** – Operators create locker records through the Django admin or web UI. Each locker is represented by a `Cell` model instance and is assigned a numeric identifier that maps to the physical hardware.
2. **QR Code Generation** – When a locker needs to be opened, the system generates a QR image and stores it in the configured `static/qr/` directory. The image contains encoded locker information.
3. **Scanning & Validation** – The user scans the QR code; the web application validates the locker ID using `LockerForm` and checks for existence in the database.
4. **Serial Command Dispatch** – The helper in `web/locker.py` opens the configured serial port, sends the unlock command to the hardware, waits for acknowledgement, and captures any connection issues.
5. **Post-Processing** – Upon success the QR image is deleted, the form resets, and a success banner is displayed. Errors bubble up as user-friendly messages without crashing the server.

The desktop launcher (`lockers.py`) simplifies deployment in kiosks by installing missing dependencies, launching Django with the correct settings module, and embedding a browser window that points to the local server.

## Installation

### Prerequisites

- Python 3.11 or newer
- System packages required to build Python wheels (e.g. `build-essential`, `libssl-dev` on Debian-based systems)
- **Desktop launcher only:** GTK 3 and Cairo development headers (`sudo apt install gir1.2-webkit2-4.0 gir1.2-gtk-3.0 libcairo2-dev`
  on Debian/Ubuntu) so that PyGObject can compile. If those packages are unavailable the
  launcher gracefully falls back to opening the Django site in the system browser.
- Access to the serial device that controls the lockers

### Installing Dependencies

```bash
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
```

The command above installs everything required for the Django web service and shared utilities. When you need the kiosk-style
desktop launcher, install the extra dependencies as well:

```bash
pip install -r requirements-desktop.txt
```

Alternatively, when installing the package from a wheel or source distribution you can request the `desktop` extra:

```bash
pip install .[desktop]
```

If you are running the packaged desktop application, the launcher automatically checks for the required libraries and installs them into an isolated environment when missing.

#### Troubleshooting PyGObject/Pycairo installation

If `pip` reports an error similar to ``Run-time dependency cairo found: NO`` while resolving
`PyGObject` or `pycairo`, install the missing system headers and retry the command:

```bash
sudo apt update
sudo apt install -y build-essential libcairo2-dev gir1.2-webkit2-4.0 gir1.2-gtk-3.0
```

When the native bindings cannot be installed (for example on minimal containers) you can still
use the desktop launcher: it will automatically open the lockers interface in your default
browser instead of embedding GTK.

### Database Setup

The default configuration uses SQLite. Apply migrations and create a superuser:

```bash
python manage.py migrate
python manage.py createsuperuser
```

## Running the Applications

### Django Development Server

```bash
python manage.py runserver 0.0.0.0:8000
```

Navigate to <http://localhost:8000> to access the operator dashboard.

### Desktop Launcher

```bash
python lockers.py
```

The launcher boots the Django server in the background (if it is not already running) and opens the kiosk browser window. Use `Ctrl+C` in the terminal to stop the application.

### Production Notes

- Configure the serial port by setting the `LOCKER_SERIAL_PORT` environment variable or editing the settings file.
- Place custom static assets or templates in the `static/` and `templates/` directories. Run `python manage.py collectstatic` before deploying to production servers.
- To bundle the desktop app with PyInstaller, use the provided `lockers.spec` file: `pyinstaller lockers.spec`.

## Testing & Development

Run the automated test suite at any time:

```bash
python -m pytest
```

The tests include hardware-independent coverage of the serial communication helpers and the desktop launcher orchestration. When contributing changes, please add or update tests to describe the new behaviour and ensure `pytest` passes before opening a pull request.

## Packaging & Release Automation

The release scripts build reproducible artefacts on each operating system. Install the packaging toolchain and lock dependencies before cutting a release:

```bash
python -m pip install -r requirements-build.txt
python -m pip install -r requirements.txt
python -m pip freeze > requirements-lock.txt
```

### Windows (x64)

```powershell
Set-ExecutionPolicy -Scope Process Bypass
python -m pip install -r requirements.txt
pyinstaller lockers.spec --noconfirm
pwsh -File scripts/build_windows.ps1
```

The script renames the PyInstaller output to `Lockers-Setup-x64.exe`, generates an `.msi` installer via the WiX toolset, and copies both artefacts plus SHA256 hashes into `dist/releases`.

### macOS (Universal)

```bash
./scripts/build_macos.sh
```

The helper builds a universal2 binary with PyInstaller, signs/notarises it when credentials are available, creates a `.dmg`, and stages the results in `dist/releases/`.

### Ubuntu 22.04/24.04

```bash
./scripts/build_ubuntu.sh
```

This wrapper installs `fpm` when missing, runs PyInstaller, assembles a `.deb` targeting `/opt/lockers-cl`, and emits a portable `.tar.gz` archive alongside updated checksums.

### Android APK

```bash
cd android
./gradlew clean assembleRelease
```

The Gradle project ships a Chromium-based WebView shell that can start a bundled backend (Termux-compatible) or point to a LAN server. Release builds land in `android/app/build/outputs/apk/release/` and are copied into `dist/releases` via `scripts/build_android.sh`.

### Continuous Delivery

GitHub Actions reproduces the full matrix in [`.github/workflows/release.yml`](.github/workflows/release.yml). Tagging a commit with `v*` or using the manual dispatch triggers the pipeline:

1. `test` – installs dependencies, runs `python -m pytest`, and executes the smoke workflow against the serial mock.
2. `build_windows`, `build_macos`, `build_linux`, and `build_android` – run the scripts above on their native runners, upload artefacts, and publish `SHA256SUMS`/`SHA256SUMS.sig`.
3. `publish` – assembles the **vNEXT** release with the generated installers and release notes.

The workflow automatically notes when signing credentials are unavailable and marks the release as an unsigned community build.

## Contributing

1. Fork the repository and create a feature branch.
2. Make your changes and add or update tests.
3. Run `python -m pytest` to verify the suite.
4. Submit a pull request describing your changes.

We welcome improvements to documentation, bug fixes, new features, and hardware integration enhancements.

## Support

If you encounter issues or have questions about extending the system, please open an issue in the repository or contact the maintainers with detailed logs, configuration snippets, and steps to reproduce the problem.

