# Lockers Control & Desktop Launcher

Welcome to the **Lockers Control** project. This repository contains two complementary applications that work together to manage a network of physical lockers:

- A Django-based web service that records locker activity, manages QR-code based access tokens, and provides an operator-friendly dashboard for opening lockers remotely.
- A lightweight cross-platform desktop utility that boots the Django backend and a bundled browser to deliver a kiosk-style experience for end users.

This document serves as the primary help page for contributors and operators. It explains how the system is structured, how it works under the hood, and how to install, configure, and run it.

## Project Overview

The system revolves around an embedded controller connected to locker hardware. Operators interact with lockers through QR codes that are generated by the web application. When a QR code is scanned, the web tier talks to the controller via serial commands to unlock the requested locker and records the transaction for auditing.

Key components:

- **`lockers.py`** – Coordinates the desktop GUI launcher, ensures Python dependencies are present, and starts the Django server in a subprocess when running in kiosk mode.
- **`web/` app** – Holds the Django models, views, forms, and URLs that power the QR code flow and the administrative pages.
- **`web/locker.py`** – Encapsulates serial communication helpers, QR-code cleanup, and command orchestration for the locker hardware.
- **`tests/`** – Regression tests that cover the desktop launcher behaviour and the locker utilities without requiring real hardware.

## How the Locker Workflow Operates

1. **Locker Definition** – Operators create locker records through the Django admin or web UI. Each locker is represented by a `Cell` model instance and is assigned a numeric identifier that maps to the physical hardware.
2. **QR Code Generation** – When a locker needs to be opened, the system generates a QR image and stores it in the configured `static/qr/` directory. The image contains encoded locker information.
3. **Scanning & Validation** – The user scans the QR code; the web application validates the locker ID using `LockerForm` and checks for existence in the database.
4. **Serial Command Dispatch** – The helper in `web/locker.py` opens the configured serial port, sends the unlock command to the hardware, waits for acknowledgement, and captures any connection issues.
5. **Post-Processing** – Upon success the QR image is deleted, the form resets, and a success banner is displayed. Errors bubble up as user-friendly messages without crashing the server.

The desktop launcher (`lockers.py`) simplifies deployment in kiosks by installing missing dependencies, launching Django with the correct settings module, and embedding a browser window that points to the local server.

## Installation

### Prerequisites

- Python 3.11 or newer
- System packages required to build Python wheels (e.g. `build-essential`, `libssl-dev` on Debian-based systems)
- **Desktop launcher only:** GTK 3 and Cairo development headers (`sudo apt install gir1.2-webkit2-4.0 gir1.2-gtk-3.0 libcairo2-dev`
  on Debian/Ubuntu) so that PyGObject can compile. If those packages are unavailable the
  launcher gracefully falls back to opening the Django site in the system browser.
- Access to the serial device that controls the lockers

### Installing Dependencies

```bash
python -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install -r requirements.txt
```

The command above installs everything required for the Django web service and shared utilities. When you need the kiosk-style
desktop launcher, install the extra dependencies as well:

```bash
pip install -r requirements-desktop.txt
```

Alternatively, when installing the package from a wheel or source distribution you can request the `desktop` extra:

```bash
pip install .[desktop]
```

If you are running the packaged desktop application, the launcher automatically checks for the required libraries and installs them into an isolated environment when missing.

#### Troubleshooting PyGObject/Pycairo installation

If `pip` reports an error similar to ``Run-time dependency cairo found: NO`` while resolving
`PyGObject` or `pycairo`, install the missing system headers and retry the command:

```bash
sudo apt update
sudo apt install -y build-essential libcairo2-dev gir1.2-webkit2-4.0 gir1.2-gtk-3.0
```

When the native bindings cannot be installed (for example on minimal containers) you can still
use the desktop launcher: it will automatically open the lockers interface in your default
browser instead of embedding GTK.

### Database Setup

The default configuration uses SQLite. Apply migrations and create a superuser:

```bash
python manage.py migrate
python manage.py createsuperuser
```

## Running the Applications

### Django Development Server

```bash
python manage.py runserver 0.0.0.0:8000
```

Navigate to <http://localhost:8000> to access the operator dashboard.

### Desktop Launcher

```bash
python lockers.py
```

The launcher boots the Django server in the background (if it is not already running) and opens the kiosk browser window. Use `Ctrl+C` in the terminal to stop the application.

### Production Notes

- Configure the serial port by setting the `LOCKER_SERIAL_PORT` environment variable or editing the settings file.
- Place custom static assets or templates in the `static/` and `templates/` directories. Run `python manage.py collectstatic` before deploying to production servers.
- To bundle the desktop app with PyInstaller, use the provided `lockers.spec` file: `pyinstaller lockers.spec`.

## Testing & Development

Run the automated test suite at any time:

```bash
python -m pytest
```

The tests include hardware-independent coverage of the serial communication helpers and the desktop launcher orchestration. When contributing changes, please add or update tests to describe the new behaviour and ensure `pytest` passes before opening a pull request.

## Building deployable apps

The repository ships with automation for creating distributable packages of the kiosk launcher. Install the build toolchain once per environment:

```bash
python -m pip install -r requirements-build.txt
```

### Ubuntu desktop packages

Use the Briefcase configuration in `pyproject.toml` together with the helper script to generate an AppImage and Debian-style bundle:

```bash
./scripts/build_ubuntu.sh
```

The script installs Briefcase if necessary, prepares the project definition, builds the binary, and deposits the packaged artifacts inside `build/lockers/linux`. System-level GTK/WebKit dependencies are declared in the Briefcase manifest and will be validated during the build.

### Android APKs

To produce a browser-based Android build that reuses the web launcher fallback, install the Android platform requirements and run:

```bash
./scripts/build_android.sh
```

Briefcase downloads the Android SDK/NDK on first use, compiles the Python bundle, and emits an unsigned APK in `build/lockers/android`. Because the kiosk experience relies on opening the Django dashboard in a system browser when GTK is not available, the Android package ships without PyGObject bindings.

### macOS app bundle

On macOS, run the helper script to produce an `.app` bundle and disk image. The script installs the platform extras (`briefcase[macOS]`) the first time it is executed.

```bash
./scripts/build_macos.sh
```

Briefcase generates the Xcode project the first time it runs, compiles the bundle, and places the resulting `.app` and `.dmg` artefacts in `build/lockers/macos`.

### Windows installer

Launch PowerShell as an administrator and execute the packaging helper. Passing `-SkipInstall` skips the dependency install if you already have Briefcase available.

```powershell
powershell -ExecutionPolicy Bypass -File scripts/build_windows.ps1
```

The Briefcase Visual Studio backend assembles an `.msi` installer and a portable `.zip` inside `build/lockers/windows`.

### Validating the desktop launcher

Regardless of platform, you can run the headless regression tests to confirm the kiosk controller works before distributing builds:

```bash
python -m pytest tests/test_desktop.py
```

The test suite stubs the serial layer so it can run without real hardware and verifies the GTK browser path and browser fallback behaviour.

## Downloadable builds

Each packaging script copies the packaged artefacts into `dist/releases` so you can publish them directly to your download portal or attach them to a GitHub release. After running the relevant build command on its target operating system, expect the following filenames:

| Platform | Script | Expected artefacts |
| --- | --- | --- |
| Ubuntu / generic Linux | `./scripts/build_ubuntu.sh` | `dist/releases/LockersControl-linux-x86_64.AppImage`, `dist/releases/LockersControl-linux-amd64.deb` |
| Android | `./scripts/build_android.sh` | `dist/releases/LockersControl-android-arm64-v8a.apk` |
| macOS | `./scripts/build_macos.sh` | `dist/releases/LockersControl-macOS-universal.dmg`, `dist/releases/LockersControl-macOS.app.zip` |
| Windows | `powershell -ExecutionPolicy Bypass -File scripts/build_windows.ps1` | `dist/releases/LockersControl-windows-x64.msi`, `dist/releases/LockersControl-windows-portable.zip` |

Copy the generated files to your preferred distribution channel or keep them in `dist/releases` for internal deployments.

## Contributing

1. Fork the repository and create a feature branch.
2. Make your changes and add or update tests.
3. Run `python -m pytest` to verify the suite.
4. Submit a pull request describing your changes.

We welcome improvements to documentation, bug fixes, new features, and hardware integration enhancements.

## Support

If you encounter issues or have questions about extending the system, please open an issue in the repository or contact the maintainers with detailed logs, configuration snippets, and steps to reproduce the problem.

